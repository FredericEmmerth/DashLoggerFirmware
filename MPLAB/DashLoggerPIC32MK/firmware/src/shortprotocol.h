/**
 * @file shortprotocol.h
 * @brief This File defines the Prototypes for \ref SHORTPROTOCOL
 * 
 * @author Frederic Emmerth
 * 
 * \ingroup SHORTPROTOCOL
 * 
 */

/**
 * \defgroup SHORTPROTOCOL SHORTPROTOCOL
 * This Module handles packing the Commands generated by the \ref SIGNAL Module
 * and sending them using the Shortprotocol defined in the Displays 
 * (EA uniTFTs035-ATC) Datasheet. To not block the Main Loop for too long, the
 * Packet is split into smaller Parts defined by 
 * SHORTPROTOCOL_Instance.maximumPackageLength. The Module is written in a 
 * general Fashion and can be adopted to use SPI, for this the Callback Functions
 * in SHORTPROTOCOL_Instance have to be redefined for SPI.
 * 
 * \addtogroup SHORTPROTOCOL
 * \{
 */

#ifndef SHORTPROTOCOL_H
#define	SHORTPROTOCOL_H

#ifdef	__cplusplus
extern "C" {
#endif
    
#include "definitions.h"
#include "crc.h"

/**
 * @brief Maximum Command length, thus maximum payload length
 */
#define SHORTPROTOCOL_MAXIMUM_COMMAND_LENGTH 100
    
/**
 * @brief The Begining Byte to indicate a Transmission
 */
#define SHORTPROTOCOL_BEGIN 0x13

/**
 * @brief The Overhead of sending Data with the Shortprotocol
 */
#define SHORTPROTOCOL_OVERHEAD_BYTES 5

/**
 * @brief The Overhead of sending Data with the Shortprotocol, not counting the 
 * two CRC Bytes.
 */
#define SHORTPROTOCOL_OVERHEAD_WITHOUT_CRC_BYTES 3

/**
 * @brief Mask to convert endianess (first Byte is on second place)
 */
#define SHORTPROTOCOL_FIRST_BYTE_MASK 0x00FF

/**
 * @brief Mask to convert endianess (second Byte in on first place)
 */
#define SHORTPROTOCOL_SECOND_BYTE_MASK 0xFF00

/**
 * @brief The length of one Byte for endianess conversion
 */
#define SHORTPROTOCOL_BYTE_LENGTH 8

/**
 * @brief The Offset of the Begin Byte in the Shortprotocol
 */
#define SHORTPROTOCOL_BEGIN_OFFSET 0
    
/**
 * @brief The Offset of the Least Significant Byte of the Length in the 
 * Shortprotocol
 */
#define SHORTPROTOCOL_LENGTH_LSB_OFFSET 1
    

/**
 * @brief The Offset of the Most Significant Byte of the Length in the 
 * Shortprotocol
 */
#define SHORTPROTOCOL_LENGTH_MSB_OFFSET 2

/**
 * @brief The Offset of the Command, thus the Payload in the Shortprotocol
 */
#define SHORTPROTOCOL_COMMAND_OFFSET 3
    
/**
 * @brief The Offset of the CRC Least Significant Byte from the Back of the 
 * Package
 */
#define SHORTPROTOCOL_CRC_LSB_OFFSET 0

/**
 * @brief The Offset of the CRC Most Significant Byte from the Back of the
 * Package
 */
#define SHORTPROTOCOL_CRC_MSB_OFFSET 1

/**
 * @brief Return Status used by both the Callback Functions of the 
 * \ref SHORTPROTOCOL and the Functions.
 */
typedef enum{
    SHORTPROTOCOL_SUCCESS = 0,
    SHORTPROTOCOL_ERROR,
    SHORTPROTOCOL_AVAILABLE,
    SHORTPROTOCOL_NOT_AVAILABLE
}SHORTPROTOCOL_status;

/**
 * @brief Struct to combine the length of a String with the String and the 
 * Overhead Bytes used by the Shortprotocol in one Data type.
 */
typedef struct{
    uint32_t length;
    uint8_t data[SHORTPROTOCOL_MAXIMUM_COMMAND_LENGTH +
                        SHORTPROTOCOL_OVERHEAD_BYTES];
}SHORTPROTOCOL_string;
    
/**
 * @brief Configuration Struct for \ref SHORTPROTOCOL passed to the 
 * \ref SHORTPROTOCOL Functions
 * 
 * The Callback functions have to all be defined as described in thier
 * Documentaion, also a maximumPackageLength has to be defined.
 */
typedef struct{
    /**
     * @brief Callback to read one Byte from the Serial Interface
     */
    uint8_t (*readByte)(void);
    
    /**
     * @brief Callback to check if a Byte is available to be read. 
     * If this returns SHORTPROTOCOL_AVAILABLE at least one Byte has to be
     * readable from readByte.
     */
    SHORTPROTOCOL_status (*readAvailable)(void);
    
    /**
     * @brief Callback to write one Byte to the Serial Interface
     */
    void (*writeByte)(uint8_t);
    
    /**
     * @brief Callbakc to check if a Byte is writeable to the Serial Interface
     * If this returns SHORTPROTOCOL_AVAILABLE at leat one Byte has to be
     * writeable to write Byte.
     */
    SHORTPROTOCOL_status (*writeAvailable)(void);
    
    /**
     * @brief The maximum Package Length
     * Packets longer than this will be split into Packets with the maximum Size
     * of maximumPackageLength.
     */
    uint32_t maximumPackageLength;
    
    /**
     * @brief A Buffer where the Command wich is currently sent resides.
     */
    SHORTPROTOCOL_string command_buffer;
    
    /**
     * @brief Status of the SHORTPROTOCOL Instance itself.
     * 
     */
    SHORTPROTOCOL_status newCommand;
    
    /**
     * @brief Counter to keep track of what Parts of a Package were already sent
     * when it is split to maximumPackageLength.
     */
    uint32_t writeCounter;
    
}SHORTPROTOCOL_Instance;
    
/**
 * @brief Function to try to send a new Command using the SHORTPROTOCOL
 * 
 * \param inst SHORTPROTOCOL_Instance
 * \param data The Data to be sent using the Shortprotocol
 * \param length The Length of the Payload (Data) to be sent
 * (without NULL termination)
 * 
 * @return SHORTPROTOCOL_NOT_AVAILABLE when the last Command was not yet sent,
 * SHORTPROTOCOL_ERROR when the Command has a length of zero,
 * SHORTPROTOCOL_SUCCESS when the Command was successfully queued to be sent.
 */
SHORTPROTOCOL_status SHORTPROTOCOL_Send(SHORTPROTOCOL_Instance* inst,
        uint8_t* data, uint32_t length);

/**
 * @brief Function to be called repeadetly in the Main Loop to send Pieces of
 * maximumPackageLength of the Package generated by SHORTPROTOCOL_Send
 * @param inst SHORTPROTOCOL_Instance
 */
void SHORTPROTOCOL_Update(SHORTPROTOCOL_Instance* inst);

/**
 * @brief Returns if a new Command can be sent using the Shortprotocol
 * @param inst SHORTPROTOCOL_Instance
 * @return SHORTPROTOCOL_AVAILABLE if a new Command can be written using the 
 * SHORTPROTOCOL_Send Function, SHORTPROTOCOL_NOT_AVAILABLE if the last 
 * Command is not yet sent.
 */
SHORTPROTOCOL_status SHORTPROTOCOL_Available(SHORTPROTOCOL_Instance* inst);

/**
 * @brief Initializes an Empty SHORTPROTOCOL_Instance.
 * Callback Functions still have to be added/defined and the 
 * maximumPackageLength has to be set.
 * @param inst SHORTPROTOCOL_Instance
 */
void SHORTPROTOCOL_Initialize(SHORTPROTOCOL_Instance* inst);

#ifdef	__cplusplus
}
#endif

#endif	/* SHORTPROTOCOL_H */

/**
 * \}
 */

